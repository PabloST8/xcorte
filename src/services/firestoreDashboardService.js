import {
  collection,
  getDocs,
  query,
  where,
  orderBy,
  limit,
} from "firebase/firestore";
import { db } from "./firebase";

// Servi√ßo para buscar dados reais do Firestore para o dashboard
export const firestoreDashboardService = {
  // Buscar estat√≠sticas do dashboard a partir do Firestore
  async getDashboardStats(enterpriseEmail = "empresaadmin@xcortes.com") {
    console.log(
      "üìä [Dashboard] Iniciando busca de estat√≠sticas para:",
      enterpriseEmail
    );

    try {
      const stats = {
        todayAppointments: 0,
        monthlyRevenue: 0,
        totalClients: 0,
        upcomingAppointments: [],
      };

      // 1. Buscar produtos da empresa (para refer√™ncia futura)
      const productsQuery = query(
        collection(db, "products"),
        where("enterpriseEmail", "==", enterpriseEmail)
      );
      await getDocs(productsQuery);

      // 2. Buscar agendamentos (assumindo que existe cole√ß√£o bookings/appointments)
      try {
        // Primeiro tentar a estrutura de subcole√ß√£o
        let appointments = [];
        try {
          console.log("üìä [Dashboard] Tentando buscar da subcole√ß√£o...");
          const bookingsRef = collection(
            db,
            "enterprises",
            enterpriseEmail,
            "bookings"
          );
          const appointmentsSnapshot = await getDocs(bookingsRef);
          appointments = appointmentsSnapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));
          console.log(
            `üìä [Dashboard] Encontrados ${appointments.length} agendamentos na subcole√ß√£o para ${enterpriseEmail}`,
            appointments
          );
        } catch (subError) {
          console.log("üìä [Dashboard] Erro na subcole√ß√£o:", subError);
          console.log(
            "üìä [Dashboard] Tentando buscar agendamentos na cole√ß√£o global..."
          );
          // Fallback para cole√ß√£o global
          const appointmentsQuery = query(
            collection(db, "bookings"),
            where("enterpriseEmail", "==", enterpriseEmail),
            orderBy("createdAt", "desc"),
            limit(50)
          );
          const appointmentsSnapshot = await getDocs(appointmentsQuery);
          appointments = appointmentsSnapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));
          console.log(
            `üìä [Dashboard] Encontrados ${appointments.length} agendamentos na cole√ß√£o global para ${enterpriseEmail}`,
            appointments
          );
        }

        // Calcular agendamentos de hoje
        const today = new Date();
        const todayString = today.toISOString().split("T")[0]; // Formato YYYY-MM-DD

        console.log("üìä [Dashboard] Data de hoje:", {
          today: today.toISOString(),
          todayString: todayString,
        });

        const todayAppointmentsList = appointments.filter((apt) => {
          // Comparar diretamente as strings de data no formato YYYY-MM-DD
          const isToday = apt.date === todayString;

          console.log("üìä [Dashboard] Verificando agendamento:", {
            id: apt.id,
            date: apt.date,
            todayString,
            isToday,
            clientName: apt.clientName,
          });

          return isToday;
        });

        stats.todayAppointments = todayAppointmentsList.length;
        console.log(
          "üìä [Dashboard] Agendamentos de hoje:",
          stats.todayAppointments,
          todayAppointmentsList
        );

        // Calcular receita do m√™s atual
        const thisMonth =
          today.getFullYear() +
          "-" +
          String(today.getMonth() + 1).padStart(2, "0"); // Formato YYYY-MM
        console.log("üìä [Dashboard] M√™s atual:", thisMonth);

        const monthlyAppointments = appointments.filter((apt) => {
          const isThisMonth = apt.date && apt.date.startsWith(thisMonth);

          console.log("üìä [Dashboard] Verificando m√™s:", {
            id: apt.id,
            date: apt.date,
            thisMonth,
            isThisMonth,
          });

          return isThisMonth;
        });

        stats.monthlyRevenue = monthlyAppointments.reduce((total, apt) => {
          // Tentar diferentes campos onde o pre√ßo pode estar
          const price =
            apt.totalPrice || apt.productPrice || apt.price || apt.valor || 0;

          console.log(`üí∞ Dashboard - Agendamento ${apt.id}:`, {
            date: apt.date,
            totalPrice: apt.totalPrice,
            productPrice: apt.productPrice,
            price: apt.price,
            valor: apt.valor,
            priceUsed: price,
          });

          return total + price;
        }, 0);

        console.log(
          `üí∞ Dashboard - Receita mensal calculada:`,
          stats.monthlyRevenue,
          "para",
          monthlyAppointments.length,
          "agendamentos"
        );

        // Pr√≥ximos agendamentos (pr√≥ximos 5)
        console.log("üìä [Dashboard] Buscando pr√≥ximos agendamentos...");
        const futureAppointments = appointments
          .filter((apt) => {
            // Comparar datas como strings, considerando agendamentos futuros (incluindo hoje √† tarde)
            const isFuture = apt.date && apt.date >= todayString;

            console.log("üìä [Dashboard] Verificando se √© futuro:", {
              id: apt.id,
              date: apt.date,
              todayString,
              isFuture,
              clientName: apt.clientName,
            });

            return isFuture;
          })
          .sort((a, b) => {
            // Ordenar por data e hora
            const dateA = a.date + " " + (a.startTime || "00:00");
            const dateB = b.date + " " + (b.startTime || "00:00");
            return dateA.localeCompare(dateB);
          })
          .slice(0, 5);

        console.log(
          "üìä [Dashboard] Agendamentos futuros encontrados:",
          futureAppointments
        );

        stats.upcomingAppointments = futureAppointments.map((apt) => ({
          id: apt.id,
          clientName: apt.clientName || "Cliente",
          productName: apt.productName || apt.serviceName || "Servi√ßo",
          startTime: apt.startTime || "Hor√°rio n√£o definido",
          date: apt.date,
          status: apt.status || "AGENDADO",
        }));

        console.log(
          "üìä [Dashboard] Pr√≥ximos agendamentos formatados:",
          stats.upcomingAppointments
        );
      } catch (appointmentError) {
        console.log("Erro ao buscar agendamentos:", appointmentError);
        // Continuar sem agendamentos
      }

      // 3. Buscar clientes √∫nicos da empresa (usando a mesma estrutura do firestoreClientsService)
      try {
        let clientsCount = 0;

        // Estrat√©gia 1: Buscar clientes da subcole√ß√£o da empresa
        try {
          const enterpriseClientsRef = collection(
            db,
            "enterprises",
            enterpriseEmail,
            "clients"
          );
          const clientsSnapshot = await getDocs(enterpriseClientsRef);
          clientsCount = clientsSnapshot.docs.length;

          console.log(
            `Encontrados ${clientsCount} clientes na subcole√ß√£o para ${enterpriseEmail}`
          );

          // Se n√£o encontrou clientes na subcole√ß√£o, tentar buscar dos agendamentos
          if (clientsCount === 0) {
            const bookingsRef = collection(
              db,
              "enterprises",
              enterpriseEmail,
              "bookings"
            );
            const bookingsSnapshot = await getDocs(bookingsRef);

            // Contar clientes √∫nicos dos agendamentos
            const uniqueClients = new Set();
            bookingsSnapshot.forEach((doc) => {
              const booking = doc.data();
              const clientKey =
                booking.clientEmail ||
                booking.clientPhone ||
                booking.clientName;
              if (clientKey) {
                uniqueClients.add(clientKey);
              }
            });

            clientsCount = uniqueClients.size;
            console.log(
              `Encontrados ${clientsCount} clientes √∫nicos dos agendamentos para ${enterpriseEmail}`
            );
          }
        } catch (error) {
          console.log("Erro ao buscar clientes da subcole√ß√£o:", error);
        }

        stats.totalClients = clientsCount;
      } catch (clientError) {
        console.log("Erro ao buscar clientes:", clientError);
        // Usar valor padr√£o
        stats.totalClients = 0;
      }

      console.log("üìä [Dashboard] Estat√≠sticas finais:", stats);
      return { success: true, data: stats };
    } catch (error) {
      console.error("Erro ao buscar estat√≠sticas do dashboard:", error);

      // Fallback com dados b√°sicos
      return {
        success: false,
        error: error.message,
        data: {
          todayAppointments: 0,
          monthlyRevenue: 0,
          totalClients: 0,
          upcomingAppointments: [],
        },
      };
    }
  },

  // Buscar informa√ß√µes da empresa
  async getEnterpriseInfo(enterpriseEmail = "empresaadmin@xcortes.com") {
    try {
      const enterpriseQuery = query(
        collection(db, "enterprises"),
        where("email", "==", enterpriseEmail),
        limit(1)
      );
      const enterpriseSnapshot = await getDocs(enterpriseQuery);

      if (!enterpriseSnapshot.empty) {
        const enterpriseDoc = enterpriseSnapshot.docs[0];
        return {
          success: true,
          data: {
            id: enterpriseDoc.id,
            ...enterpriseDoc.data(),
          },
        };
      }

      return { success: false, error: "Empresa n√£o encontrada" };
    } catch (error) {
      console.error("Erro ao buscar informa√ß√µes da empresa:", error);
      return { success: false, error: error.message };
    }
  },

  // Buscar produtos da empresa
  async getEnterpriseProducts(enterpriseEmail = "pablofafstar@gmail.com") {
    try {
      const productsQuery = query(
        collection(db, "products"),
        where("enterpriseEmail", "==", enterpriseEmail)
      );
      const productsSnapshot = await getDocs(productsQuery);

      const products = productsSnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      return { success: true, data: products };
    } catch (error) {
      console.error("Erro ao buscar produtos:", error);
      return { success: false, error: error.message, data: [] };
    }
  },
};
